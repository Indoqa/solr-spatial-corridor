<?xml version="1.0" encoding="UTF-8" ?>
<config>
  <abortOnConfigurationError>${solr.abortOnConfigurationError:true}</abortOnConfigurationError>
  <dataDir>${solr.data.dir:}</dataDir>
  <luceneMatchVersion>LUCENE_CURRENT</luceneMatchVersion>

  <indexConfig>
    <useCompoundFile>false</useCompoundFile>
    <mergeFactor>10</mergeFactor>
    <ramBufferSizeMB>32</ramBufferSizeMB>
    <maxFieldLength>10000</maxFieldLength>
    <writeLockTimeout>1000</writeLockTimeout>
    <commitLockTimeout>10000</commitLockTimeout>
    <lockType>native</lockType>
    <unlockOnStartup>true</unlockOnStartup>
    <reopenReaders>true</reopenReaders>
    <deletionPolicy class="solr.SolrDeletionPolicy">
      <str name="maxCommitsToKeep">1</str>
      <str name="maxOptimizedCommitsToKeep">0</str>
    </deletionPolicy>
    <infoStream file="INFOSTREAM.txt">false</infoStream>
  </indexConfig>

  <directoryProvider class="org.apache.lucene.store.RAMDirectory">
    <!-- Parameters as required by the implementation -->
  </directoryProvider>

  <updateHandler class="solr.DirectUpdateHandler2">
    <!-- Perform a <commit/> automatically under certain conditions: maxDocs - number of updates since last commit is greater than this maxTime - oldest
      uncommited update (in ms) is this long ago -->
    <autoCommit>
      <maxDocs>1000</maxDocs>
      <maxTime>60000</maxTime>
    </autoCommit>
  </updateHandler>


  <query>
    <maxBooleanClauses>1024</maxBooleanClauses>
    <filterCache class="solr.LRUCache" size="512" initialSize="512" autowarmCount="128" />

    <queryResultCache class="solr.LRUCache" size="512" initialSize="512" autowarmCount="32" />

    <documentCache class="solr.LRUCache" size="512" initialSize="512" autowarmCount="0" />

    <cache name="corridorLineStrings"
           class="solr.LRUCache"
           size="4096"
           initialSize="2048"
           autowarmCount="4096"/>

    <enableLazyFieldLoading>true</enableLazyFieldLoading>
    <queryResultWindowSize>50</queryResultWindowSize>
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>
    <HashDocSet maxSize="3000" loadFactor="0.75" />

    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst>
          <str name="q">solr</str>
          <str name="start">0</str>
          <str name="rows">10</str>
        </lst>
        <lst>
          <str name="q">rocks</str>
          <str name="start">0</str>
          <str name="rows">10</str>
        </lst>
        <lst>
          <str name="q">static newSearcher warming query from solrconfig.xml</str>
        </lst>
      </arr>
    </listener>

    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst>
          <str name="q">fast_warm</str>
          <str name="start">0</str>
          <str name="rows">10</str>
        </lst>
        <lst>
          <str name="q">static firstSearcher warming query from solrconfig.xml</str>
        </lst>
      </arr>
    </listener>

    <useColdSearcher>false</useColdSearcher>
    <maxWarmingSearchers>2</maxWarmingSearchers>
  </query>

  <!-- Let the dispatch filter handler /select?qt=XXX handleSelect=true will use consistent error handling for /select and /update handleSelect=false will
    use solr1.1 style error formatting -->
  <requestDispatcher handleSelect="true">
    <!--Make sure your system has some authentication before enabling remote streaming! -->
    <requestParsers enableRemoteStreaming="false" multipartUploadLimitInKB="2048" />

    <!-- Set HTTP caching related parameters (for proxy caches and clients). To get the behaviour of Solr 1.2 (ie: no caching related headers) use the
      never304="true" option and do not specify a value for <cacheControl> -->
    <!-- <httpCaching never304="true"> -->
    <httpCaching lastModifiedFrom="openTime" etagSeed="Solr">
      <!-- lastModFrom="openTime" is the default, the Last-Modified value (and validation against If-Modified-Since requests) will all be relative to when
        the current Searcher was opened. You can change it to lastModFrom="dirLastMod" if you want the value to exactly corrispond to when the physical index was
        last modified. etagSeed="..." is an option you can change to force the ETag header (and validation against If-None-Match requests) to be differnet even
        if the index has not changed (ie: when making significant changes to your config file) lastModifiedFrom and etagSeed are both ignored if you use the never304="true"
        option. -->
      <!-- If you include a <cacheControl> directive, it will be used to generate a Cache-Control header, as well as an Expires header if the value contains
        "max-age=" By default, no Cache-Control header is generated. You can use the <cacheControl> option even if you have set never304="true" -->
      <!-- <cacheControl>max-age=30, public</cacheControl> -->
    </httpCaching>
  </requestDispatcher>


  <!-- requestHandler plugins... incoming queries will be dispatched to the correct handler based on the path or the qt (query type) param. Names starting
    with a '/' are accessed with the a path equal to the registered name. Names without a leading '/' are accessed with: http://host/app/select?qt=name If
    no qt is defined, the requestHandler that declares default="true" will be used. -->
  <requestHandler name="standard" class="solr.SearchHandler" default="true">
    <!-- default values for query parameters -->
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <!-- <int name="rows">10</int> <str name="fl">*</str> <str name="version">2.1</str> -->
    </lst>
  </requestHandler>


  <!-- DisMaxRequestHandler allows easy searching across multiple fields for simple user-entered phrases. It's implementation is now just the standard
    SearchHandler with a default query type of "dismax". see http://wiki.apache.org/solr/DisMaxRequestHandler -->
  <requestHandler name="dismax" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="defType">dismax</str>
      <str name="echoParams">explicit</str>
      <float name="tie">0.01</float>
      <str name="qf">
        text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0 manu^1.1 cat^1.4
      </str>
      <str name="pf">
        text^0.2 features^1.1 name^1.5 manu^1.4 manu_exact^1.9
      </str>
      <str name="bf">
        ord(popularity)^0.5 recip(rord(price),1,1000,1000)^0.3
      </str>
      <str name="fl">
        id,name,price,score
      </str>
      <str name="mm">
        2&lt;-1 5&lt;-2 6&lt;90% </str>
      <int name="ps">100</int>
      <str name="q.alt">*:*</str>
      <!-- example highlighter config, enable per-query with hl=true -->
      <str name="hl.fl">text features name</str>
      <!-- for this field, we want no fragmenting, just highlighting -->
      <str name="f.name.hl.fragsize">0</str>
      <!-- instructs Solr to return the field itself if no query terms are found -->
      <str name="f.name.hl.alternateField">name</str>
      <str name="f.text.hl.fragmenter">regex</str> <!-- defined below -->
    </lst>
  </requestHandler>

  <!-- Note how you can register the same handler multiple times with different names (and different init parameters) -->
  <requestHandler name="partitioned" class="solr.SearchHandler">
    <lst name="defaults">
      <str name="defType">dismax</str>
      <str name="echoParams">explicit</str>
      <str name="qf">text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0</str>
      <str name="mm">2&lt;-1 5&lt;-2 6&lt;90%</str>
      <!-- This is an example of using Date Math to specify a constantly moving date range in a config... -->
      <str name="bq">incubationdate_dt:[* TO NOW/DAY-1MONTH]^2.2</str>
    </lst>
    <!-- In addition to defaults, "appends" params can be specified to identify values which should be appended to the list of multi-val params from the
      query (or the existing "defaults"). In this example, the param "fq=instock:true" will be appended to any query time fq params the user may specify, as
      a mechanism for partitioning the index, independent of any user selected filtering that may also be desired (perhaps as a result of faceted searching).
      NOTE: there is *absolutely* nothing a client can do to prevent these "appends" values from being used, so don't use this mechanism unless you are sure
      you always want it. -->
    <lst name="appends">
      <str name="fq">inStock:true</str>
    </lst>
    <!-- "invariants" are a way of letting the Solr maintainer lock down the options available to Solr clients. Any params values specified here are used
      regardless of what values may be specified in either the query, the "defaults", or the "appends" params. In this example, the facet.field and facet.query
      params are fixed, limiting the facets clients can use. Faceting is not turned on by default - but if the client does specify facet=true in the request,
      these are the only facets they will be able to see counts for; regardless of what other facet.field or facet.query params they may specify. NOTE: there
      is *absolutely* nothing a client can do to prevent these "invariants" values from being used, so don't use this mechanism unless you are sure you always
      want it. -->
    <lst name="invariants">
      <str name="facet.field">cat</str>
      <str name="facet.field">manu_exact</str>
      <str name="facet.query">price:[* TO 500]</str>
      <str name="facet.query">price:[500 TO *]</str>
    </lst>
  </requestHandler>


  <!-- Search components are registered to SolrCore and used by Search Handlers By default, the following components are avaliable: <searchComponent name="query"
    class="org.apache.solr.handler.component.QueryComponent" /> <searchComponent name="facet" class="org.apache.solr.handler.component.FacetComponent" /> <searchComponent
    name="mlt" class="org.apache.solr.handler.component.MoreLikeThisComponent" /> <searchComponent name="highlight" class="org.apache.solr.handler.component.HighlightComponent"
    /> <searchComponent name="debug" class="org.apache.solr.handler.component.DebugComponent" /> Default configuration in a requestHandler would look like:
    <arr name="components"> <str>query</str> <str>facet</str> <str>mlt</str> <str>highlight</str> <str>debug</str> </arr> If you register a searchComponent
    to one of the standard names, that will be used instead. To insert handlers before or after the 'standard' components, use: <arr name="first-components">
    <str>myFirstComponentName</str> </arr> <arr name="last-components"> <str>myLastComponentName</str> </arr> -->

  <!-- The spell check component can return a list of alternative spelling suggestions. -->
  <searchComponent name="spellcheck" class="solr.SpellCheckComponent">

    <str name="queryAnalyzerFieldType">textSpell</str>

    <lst name="spellchecker">
      <str name="name">default</str>
      <str name="field">spell</str>
      <str name="spellcheckIndexDir">./spellchecker1</str>

    </lst>
    <lst name="spellchecker">
      <str name="name">jarowinkler</str>
      <str name="field">spell</str>
      <!-- Use a different Distance Measure -->
      <str name="distanceMeasure">org.apache.lucene.search.spell.JaroWinklerDistance</str>
      <str name="spellcheckIndexDir">./spellchecker2</str>

    </lst>

    <lst name="spellchecker">
      <str name="classname">solr.FileBasedSpellChecker</str>
      <str name="name">file</str>
      <str name="sourceLocation">spellings.txt</str>
      <str name="characterEncoding">UTF-8</str>
      <str name="spellcheckIndexDir">./spellcheckerFile</str>
    </lst>
  </searchComponent>

  <!-- a request handler utilizing the spellcheck component -->
  <requestHandler name="/spellCheckCompRH" class="solr.SearchHandler">
    <lst name="defaults">
      <!-- omp = Only More Popular -->
      <str name="spellcheck.onlyMorePopular">false</str>
      <!-- exr = Extended Results -->
      <str name="spellcheck.extendedResults">false</str>
      <!-- The number of suggestions to return -->
      <str name="spellcheck.count">1</str>
    </lst>
    <arr name="last-components">
      <str>spellcheck</str>
    </arr>
  </requestHandler>

  <!-- a search component that enables you to configure the top results for a given query regardless of the normal lucene scoring. <searchComponent name="elevator"
    class="solr.QueryElevationComponent" > <str name="queryFieldType">string</str> <str name="config-file">elevate.xml</str> </searchComponent> -->
  <!-- a request handler utilizing the elevator component -->
  <requestHandler name="/elevate" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
    </lst>
    <arr name="last-components">
      <str>elevator</str>
    </arr>
  </requestHandler>

  <valueSourceParser name="inRouteDirection"
                     class="com.indoqa.solr.spatial.corridor.query.route.InDirectionValueSourceParser"/>

  <!-- Update request handler. Note: Since solr1.1 requestHandlers requires a valid content type header if posted in the body. For example, curl now requires:
    -H 'Content-type:text/xml; charset=utf-8' The response format differs from solr1.1 formatting and returns a standard error code. To enable solr1.1 behavior,
    remove the /update handler or change its path -->
  <!-- requestHandler name="/update" class="solr.XmlUpdateRequestHandler" / -->

  <requestHandler name="/update" class="solr.XmlUpdateRequestHandler">
    <lst name="invariants">
      <str name="update.processor">lovoChain</str>
    </lst>
  </requestHandler>

  <updateRequestProcessorChain name="lovoChain">
    <processor class="solr.RunUpdateProcessorFactory" />
    <processor class="solr.LogUpdateProcessorFactory" />
  </updateRequestProcessorChain>



  <!-- CSV update handler, loaded on demand -->
  <requestHandler name="/update/csv" class="solr.CSVRequestHandler" startup="lazy" />


  <!-- Admin Handlers - This will register all the standard admin RequestHandlers. Adding this single handler is equivolent to registering: <requestHandler
    name="/admin/luke" class="org.apache.solr.handler.admin.LukeRequestHandler" /> <requestHandler name="/admin/system" class="org.apache.solr.handler.admin.SystemInfoHandler"
    /> <requestHandler name="/admin/plugins" class="org.apache.solr.handler.admin.PluginInfoHandler" /> <requestHandler name="/admin/threads" class="org.apache.solr.handler.admin.ThreadDumpHandler"
    /> <requestHandler name="/admin/properties" class="org.apache.solr.handler.admin.PropertiesRequestHandler" /> <requestHandler name="/admin/file" class="org.apache.solr.handler.admin.ShowFileRequestHandler"
    > If you wish to hide files under ${solr.home}/conf, explicitly register the ShowFileRequestHandler using: <requestHandler name="/admin/file" class="org.apache.solr.handler.admin.ShowFileRequestHandler"
    > <lst name="invariants"> <str name="hidden">synonyms.txt</str> <str name="hidden">anotherfile.txt</str> </lst> </requestHandler> -->
  <requestHandler name="/admin/" class="org.apache.solr.handler.admin.AdminHandlers" />

  <!-- ping/healthcheck -->
  <requestHandler name="/admin/ping" class="PingRequestHandler">
    <lst name="defaults">
      <str name="qt">standard</str>
      <str name="q">solrpingquery</str>
      <str name="echoParams">all</str>
    </lst>
  </requestHandler>

  <!-- Echo the request contents back to the client -->
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str> <!-- for all params (including the default etc) use: 'all' -->
      <str name="echoHandler">true</str>
    </lst>
  </requestHandler>

  <highlighting>
    <!-- Configure the standard fragmenter -->
    <!-- This could most likely be commented out in the "default" case -->
    <fragmenter name="gap" class="org.apache.solr.highlight.GapFragmenter" default="true">
      <lst name="defaults">
        <int name="hl.fragsize">100</int>
      </lst>
    </fragmenter>

    <!-- A regular-expression-based fragmenter (f.i., for sentence extraction) -->
    <fragmenter name="regex" class="org.apache.solr.highlight.RegexFragmenter">
      <lst name="defaults">
        <!-- slightly smaller fragsizes work better because of slop -->
        <int name="hl.fragsize">70</int>
        <!-- allow 50% slop on fragment sizes -->
        <float name="hl.regex.slop">0.5</float>
        <!-- a basic sentence pattern -->
        <str name="hl.regex.pattern">[-\w ,/\n\"']{20,200}</str>
      </lst>
    </fragmenter>

    <!-- Configure the standard formatter -->
    <formatter name="html" class="org.apache.solr.highlight.HtmlFormatter" default="true">
      <lst name="defaults">
        <str name="hl.simple.pre"><![CDATA[<em>]]></str>
        <str name="hl.simple.post"><![CDATA[</em>]]></str>
      </lst>
    </formatter>
  </highlighting>

  <!-- config for the admin interface -->
  <admin>
    <defaultQuery>solr</defaultQuery>
  </admin>

</config>
